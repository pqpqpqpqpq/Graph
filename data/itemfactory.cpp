/****************************************************************************
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** Author: panqing
** email: zjupanqing@gmail.com
**
****************************************************************************/

#include <math.h>

#include <QList>
#include <QHash>
#include <QDebug>

#include "itemfactory.h"
#include "main/resmanager.h"
#include "main/itemcontainer.h"
#include "ui/items/hexagonitem.h"
#include "ui/items/nodeelement.h"
#include "ui/items/edgeelement.h"
#include "ui/items/subedgeitem.h"
#include "ui/widgets/topographicsview.h"
#include "ui/items/mainnodeitem.h"
#include "data/edgeattr.h"
#include "data/hexagonpoint.h"

qreal ItemFactory::HEXAGON_EDGE_LENGTH = ResManager::settings.value("SceneSize/element_edge_length").toDouble();

ItemFactory::ItemFactory()
:	QObject()
{

}

/*!
	\brief Add MainNodeItem & SubNodeItem to the scene
*/
void ItemFactory::addNodeItems(TopoGraphicsView *graphicsView)
{
	QHash<quint32, NodeItem *> &nodeHash = ItemContainer::nodeHash;
	if(!nodeHash.isEmpty())
	{
		QHash<quint32, NodeItem *>::const_iterator it;
		for(it=nodeHash.constBegin();
			it!=nodeHash.constEnd();
			it++)
		{
			(*it)->setTopoGraphicsView(graphicsView);
			graphicsView->scene()->addItem(*it);
		}
	}
}

///*!
//	Add the NodeElements generated by discretization to the scene
//*/
//void ItemFactory::addElements(TopoGraphicsView *graphicsView)
//{
//	QHash<quint32, NodeItem *> &nodeHash = ItemContainer::nodeHash;
//
//	QList<EdgeAttr *> &mainEdgeAttrList = ItemContainer::mainEdgeAttrList;
//	QList<EdgeAttr *>::const_iterator edgeAttrListListIt;
//
//	QHash<quint32, NodeItem *> tempNodeHash;
//
//	for (edgeAttrListListIt = mainEdgeAttrList.constBegin(); 
//		edgeAttrListListIt != mainEdgeAttrList.constEnd(); 
//		++edgeAttrListListIt)
//	{
//		EdgeAttr *edgeAttr = *edgeAttrListListIt;
//		QList<NodeItem *> tempNodeItemList;
//
//		if (nodeHash.contains(edgeAttr->getIntAttr(EdgeAttr::STARTNODE))
//			&& nodeHash.contains(edgeAttr->getIntAttr(EdgeAttr::ENDNODE)))
//		{
//			// the number of elements per segment
//			// quint16 element_num = edgeAttr->getDoubleAttr(EdgeAttr::LENGTH)/40;
//			quint16 element_num = edgeAttr->getDoubleAttr(EdgeAttr::ALLSUBLENGTH)/HEXAGON_EDGE_LENGTH;
//
//			// order in the tempNodeItemList:
//			// startNode, nodeElements, endNode
//
//			// Create startNode
//			MainNodeItem *existStartNode = qgraphicsitem_cast<MainNodeItem *>(nodeHash.value(edgeAttr->getIntAttr(EdgeAttr::STARTNODE)));
//			MainNodeItem *startNode = NULL;
//			// MainNodeItem objects are created twice
//			// Once in plotting sub node and edge items
//			// Once in plotting node and edge elements
//			if (!tempNodeHash.contains(edgeAttr->getIntAttr(EdgeAttr::STARTNODE)))
//			{
//				startNode = new MainNodeItem(graphicsView, edgeAttr->getIntAttr(EdgeAttr::STARTNODE));
//				tempNodeHash.insert(edgeAttr->getIntAttr(EdgeAttr::STARTNODE), startNode);
//			}
//			else
//			{
//				startNode = qgraphicsitem_cast<MainNodeItem *>(tempNodeHash.value(edgeAttr->getIntAttr(EdgeAttr::STARTNODE)));
//			}
//			startNode->setPos(existStartNode->pos());
//			startNode->setStable(true);
//			graphicsView->scene()->addItem(startNode);
//			tempNodeItemList << startNode;
//
//			// Create NodeElement
//			// the number of node elements = number of elements - 1
//			for (int i=0; i<element_num-1; i++)
//			{
//				NodeElement *tempNodeElement = new NodeElement(graphicsView);
//				tempNodeElement->setPos(existStartNode->pos());
//				// tempNodeElement->setStable(true);
//				tempNodeItemList << tempNodeElement;
//				graphicsView->scene()->addItem(tempNodeElement);
//			}
//
//			// Create endNode
//			MainNodeItem *existEndNode = qgraphicsitem_cast<MainNodeItem *>(nodeHash.value(edgeAttr->getIntAttr(EdgeAttr::ENDNODE)));
//			MainNodeItem *endNode = NULL;
//			if (!tempNodeHash.contains(edgeAttr->getIntAttr(EdgeAttr::ENDNODE)))
//			{
//				endNode = new MainNodeItem(graphicsView, edgeAttr->getIntAttr(EdgeAttr::ENDNODE));
//				tempNodeHash.insert(edgeAttr->getIntAttr(EdgeAttr::ENDNODE), endNode);
//			}
//			else
//			{
//				endNode = qgraphicsitem_cast<MainNodeItem *>(tempNodeHash.value(edgeAttr->getIntAttr(EdgeAttr::ENDNODE)));
//			}
//			endNode->setPos(existEndNode->pos());
//			endNode->setStable(true);
//			graphicsView->scene()->addItem(endNode);
//			tempNodeItemList << endNode;
//
//			// Create EdgeElement
//			for (int i=0; i<element_num; i++)
//			{
//				EdgeElement *tempEdge = new EdgeElement(tempNodeItemList.at(i), tempNodeItemList.at(i+1));
//				tempEdge->setEdgeAttr(edgeAttr);	// set the attribute list of the EdgeElement
//				graphicsView->scene()->addItem(tempEdge);
//			}
//		}
//	}
//}

/*!
	\brief Create and add SubEdgeItem to the scene
*/
void ItemFactory::addSubEdgeItems(TopoGraphicsView *graphicsView)
{
  QList<EdgeItem *> &edgeItemList = ItemContainer::edgeItemList;

  QList<EdgeItem *>::const_iterator edgeItemListIt;
  for (edgeItemListIt = edgeItemList.constBegin();
    edgeItemListIt != edgeItemList.constEnd();
    ++edgeItemListIt)
  {
    EdgeItem *tempEdgeItem = *edgeItemListIt;
    graphicsView->scene()->addItem(tempEdgeItem);
  }
}

/*!
	\brief Put all the MainNodeItem to the hexagon grid point
*/
void ItemFactory::locateNodeItems(TopoGraphicsView *graphicsView)
{
	QLineF lineF;
	HexagonPoint *minPoint = NULL;

	QList<HexagonPoint *> &hexagonPointList = ResManager::hexagonPointList;
	const QList<QGraphicsItem *> allItemList = graphicsView->items();
	QList<QGraphicsItem *>::const_iterator allItemListIt;
	for (allItemListIt = allItemList.constBegin();
		allItemListIt != allItemList.constEnd();
		++allItemListIt)
	{
		qreal minLength = HEXAGON_EDGE_LENGTH*1.25;	// the minimum length between the nodeItem and the hexagon point
		QGraphicsItem *item = *allItemListIt;
		if (MainNodeItem *nodeItem = qgraphicsitem_cast<MainNodeItem *>(item))
		{
			// Traversal all the hexagon points. Find the point nearest to the current NodeItem.
			QList<HexagonPoint *>::const_iterator hexagonPointIt;
			for (hexagonPointIt = hexagonPointList.constBegin();
				hexagonPointIt != hexagonPointList.constEnd();
				++hexagonPointIt)
			{
				lineF = QLineF(nodeItem->pos(), **hexagonPointIt);
				if (lineF.length() < minLength)
				{
					minLength = lineF.length();
					minPoint = *hexagonPointIt;
					break;
				}
			}
			if (minPoint != NULL)
			{
				nodeItem->setPos(*minPoint);
				minPoint->setOccupied(true);
			}
		}
	}
}

/*!
	\brief Add HexgonItem to the scene
	It also set the position of all the added items
*/
void ItemFactory::addHexagonItems(TopoGraphicsView *graphicsView)
{
	quint16 horizonNum = graphicsView->scene()->width()/(HEXAGON_EDGE_LENGTH*3);
	quint16 verticalNum = graphicsView->scene()->height()/(HEXAGON_EDGE_LENGTH*sqrt(3.0));

	quint32 hexagonItemIndex = 0;
	HexagonItem *hexagonItem = NULL;
	for (int i=0; i<verticalNum; ++i)
	{
		for (int j=0; j<horizonNum; ++j)
		{
			// the hexagon near to the left margin
			hexagonItem = new HexagonItem();
			qreal origin_x = -graphicsView->scene()->width()/2 - HEXAGON_EDGE_LENGTH*2 + HEXAGON_EDGE_LENGTH*3*(j+1);
			qreal origin_y = graphicsView->scene()->height()/2 - HEXAGON_EDGE_LENGTH*sqrt(3.0)*(i+1);
			graphicsView->scene()->addItem(hexagonItem);
			hexagonItem->setPos(origin_x, origin_y);
			hexagonItem->setIndex(hexagonItemIndex);
			++hexagonItemIndex;

			// the hexagon near to the bottom margin
			hexagonItem = new HexagonItem();
			origin_x = -graphicsView->scene()->width()/2 - HEXAGON_EDGE_LENGTH/2 + HEXAGON_EDGE_LENGTH*3*(j+1);
			origin_y = graphicsView->scene()->height()/2 + HEXAGON_EDGE_LENGTH/2*sqrt(3.0) - HEXAGON_EDGE_LENGTH*sqrt(3.0)*(i+1);
			graphicsView->scene()->addItem(hexagonItem);
			hexagonItem->setPos(origin_x, origin_y);
			hexagonItem->setIndex(hexagonItemIndex);
			++hexagonItemIndex;
		}
	}
	saveHexagonPoint(graphicsView);
	// connectHexagonPoint();	// TODO(panqing): It takes too much time
	qDebug() << hexagonItemIndex;
}

/*!
	\brief Save HexagonPoint to a QList container
*/
void ItemFactory::saveHexagonPoint(TopoGraphicsView *graphicsView)
{
	QList<HexagonPoint *> &hexagonPointList = ResManager::hexagonPointList;
	qreal horizonOffset = graphicsView->scene()->width()/2;
	qreal verticalOffset = graphicsView->scene()->height()/2;
	quint16 horizonNum = graphicsView->scene()->width()/(HEXAGON_EDGE_LENGTH*3);
	quint16 verticalNum = graphicsView->scene()->height()/(HEXAGON_EDGE_LENGTH*0.5*sqrt(3.0));

	HexagonPoint *hexagonPoint[2];
	for (int i=0; i<verticalNum; ++i)
	{
		for (int j=0; j<horizonNum; ++j)
		{
			if (i%2==1)	// why?
			{
				hexagonPoint[0] = new HexagonPoint(
					3.0*j*HEXAGON_EDGE_LENGTH+0.5*HEXAGON_EDGE_LENGTH-horizonOffset, 
					verticalOffset-0.5*sqrt(3.0)*i*HEXAGON_EDGE_LENGTH);
				hexagonPoint[1] = new HexagonPoint(
					3.0*j*HEXAGON_EDGE_LENGTH+1.5*HEXAGON_EDGE_LENGTH-horizonOffset,
					verticalOffset-0.5*sqrt(3.0)*i*HEXAGON_EDGE_LENGTH);
			} 
			else
			{
				hexagonPoint[0] = new HexagonPoint(
					3.0*j*HEXAGON_EDGE_LENGTH-horizonOffset, 
					verticalOffset-0.5*sqrt(3.0)*i*HEXAGON_EDGE_LENGTH);
				hexagonPoint[1] = new HexagonPoint(
					3.0*j*HEXAGON_EDGE_LENGTH+2*HEXAGON_EDGE_LENGTH-horizonOffset,
					verticalOffset-0.5*sqrt(3.0)*i*HEXAGON_EDGE_LENGTH);
			}
			hexagonPointList.append(hexagonPoint[0]);
			hexagonPointList.append(hexagonPoint[1]);
		}
	}
}

/*!
	\brief Determine the adjacent relationship among the hexagonal grid points
	If point1 and point2 are adjacent, put each of the point to the other's adjacent list
*/
void ItemFactory::connectHexagonPoint()
{
	QList<HexagonPoint *> &hexagonPointList = ResManager::hexagonPointList;
	qreal x_diff, y_diff, dis, dis_diff;
	QList<HexagonPoint *>::const_iterator it1, it2;
	for (it1 = hexagonPointList.constBegin();
		it1 != hexagonPointList.constEnd();
		++it1)
	{
		for (it2 = it1+1;
			it2 != hexagonPointList.constEnd();
			++it2)
		{
			x_diff = (*it1)->x()-(*it2)->x();
			y_diff = (*it1)->y()-(*it2)->y();
			dis = sqrt(x_diff*x_diff + y_diff*y_diff);
			dis_diff = HEXAGON_EDGE_LENGTH-dis;
			if (dis_diff<HEXAGON_EDGE_LENGTH*sqrt(3.0))
			{
				(*it1)->addAdjPoint(*it2);
				(*it2)->addAdjPoint(*it1);
			}
		}
	}
}

void ItemFactory::addFindedLineItem(TopoGraphicsView *graphicsView)
{
	QGraphicsLineItem *findedLine = ItemContainer::findedLine;
	graphicsView->scene()->addItem(findedLine);

}
